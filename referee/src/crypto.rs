// referee/src/crypto.rs
// Eä Referee Crypto Engine v5.0 — Compatible with Muscle Compiler v5.0
#![forbid(unsafe_code)]

use aes_gcm_siv::{Aes256GcmSiv, KeyInit, Nonce, aead::Aead};
use blake3::{Hasher, OUT_LEN};
use subtle::ConstantTimeEq;
use zeroize::Zeroize;
use alloc::vec::Vec;

/// Protocol version — must match muscle compiler
const PROTOCOL_VERSION: &[u8] = b"Ea/muscle/v5.0";

/// Domain separation constants (must match muscle compiler)
const DOMAIN_KDF: [u8; 32] = *b"\xde\xad\xbe\xef\xca\xfe\xba\xbe\x01\x23\x45\x67\x89\xab\xcd\xef\
                                 \xde\xad\xbe\xef\xca\xfe\xba\xbe\x01\x23\x45\x67\x89\xab\xcd\xef";
const DOMAIN_MAC: [u8; 32] = *b"\xf0\x0d\xfa\xce\xfe\xed\xba\xbe\x88\x77\x66\x55\x44\x33\x22\x11\
                                 \xf0\x0d\xfa\xce\xfe\xed\xba\xbe\x88\x77\x66\x55\x44\x33\x22\x11";

pub type MuscleSalt = [u8; 16];
pub type MuscleVersion = u64;

/// For referee, we only support classical mode (no PQ overhead)
const KEM_CT_LEN: usize = 0;
pub const FIXED_OVERHEAD: usize = KEM_CT_LEN + 8 + 12 + 32;
pub const MIN_BLOB_SIZE: usize = FIXED_OVERHEAD;

/// Derive key with domain separation (matches muscle compiler)
fn derive(key_material: &[u8; 32], salt: &MuscleSalt, domain: &[u8; 32]) -> [u8; 32] {
    let mut h = Hasher::new_keyed(key_material);
    h.update(PROTOCOL_VERSION);
    h.update(domain);
    h.update(salt);
    *h.finalize().as_bytes()
}

/// Open muscle blob with v5.0 crypto
pub fn open(
    master: &[u8; 32],
    salt: &MuscleSalt,
    sealed: &[u8],
) -> Result<(Vec<u8>, MuscleVersion), &'static str> {
    if sealed.len() < MIN_BLOB_SIZE {
        return Err("sealed data too small");
    }

    // Parse blob structure (classical mode only)
    let kem_ct = &sealed[..KEM_CT_LEN];
    let version_bytes = &sealed[KEM_CT_LEN..KEM_CT_LEN + 8];
    let nonce = &sealed[KEM_CT_LEN + 8..KEM_CT_LEN + 20];
    let ciphertext = &sealed[KEM_CT_LEN + 20..sealed.len() - OUT_LEN];
    let received_tag = &sealed[sealed.len() - OUT_LEN..];

    let version = u64::from_le_bytes(version_bytes.try_into().unwrap());

    // In classical mode, shared secret is derived directly from master + salt
    let mut shared_secret = derive(master, salt, &DOMAIN_KDF);

    let mut enc_key = derive(&shared_secret, salt, &DOMAIN_KDF);
    let mut mac_key = derive(&shared_secret, salt, &DOMAIN_MAC);

    // Verify MAC first (constant-time)
    let mut h = Hasher::new_keyed(&mac_key);
    h.update(PROTOCOL_VERSION);
    h.update(salt);
    h.update(kem_ct);
    h.update(&version.to_le_bytes());
    h.update(nonce);
    h.update(ciphertext);
    
    if !bool::from(h.finalize().as_bytes().ct_eq(received_tag)) {
        return Err("integrity check failed");
    }

    // Decrypt after verification
    let plaintext = Aes256GcmSiv::new(&enc_key.into())
        .decrypt(Nonce::from_slice(nonce), ciphertext)
        .map_err(|_| "decryption failed")?;

    // Cleanup
    shared_secret.zeroize();
    enc_key.zeroize();
    mac_key.zeroize();

    Ok((plaintext, version))
}

/// Fast-path opening for performance
pub fn open_infallible(
    master: &[u8; 32],
    salt: &MuscleSalt,
    sealed: &[u8],
) -> Option<(Vec<u8>, MuscleVersion)> {
    open(master, salt, sealed).ok()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_roundtrip_compatibility() {
        // This test would use data generated by the muscle compiler
        // For now, we test the basic crypto operations
        
        let master = [0x42; 32];
        let salt = [0x13; 16];
        let test_data = b"test muscle code";
        
        // Note: In production, sealing happens in muscle compiler
        // Referee only handles opening
        assert!(open(&master, &salt, &[]).is_err());
    }
}
